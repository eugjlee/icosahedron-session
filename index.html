<!DOCTYPE html>
<script src='vendor/three.js/build/three.js'></script>
<script src="vendor/three.js/examples/js/Detector.js"></script>
<script src="vendor/threex.windowresize.js"></script>

<body style='margin: 0px; background-color: #bbbbbb; overflow: hidden;'>
    <script>
    var camera, scene, renderer;
    var geometry, material, mesh;

    var speedX = 0.01;
    var speedY = 0.01;

    var orVertices = [];

    var light2, light3;

    var init = function() {

        renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 1000);
        camera.position.z = 500;

        scene = new THREE.Scene();

        geometry = new THREE.IcosahedronGeometry(100, 1);
        //geometry = new THREE.BoxGeometry(100,100,100,2,2,2);
        material = new THREE.MeshLambertMaterial({
            color: 0xffffff,
            shading: THREE.FlatShading,
            wireframe: false
        });

        for (var i = 0; i < geometry.vertices.length; i++) {
            orVertices.push(geometry.vertices[i].clone());
        }

        mesh = new THREE.Mesh(geometry, material);
        scene.add(mesh);

        var light = new THREE.HemisphereLight(0xffffff, 0x010101, 1);
        scene.add(light);

        light2 = new THREE.PointLight(0xff0000, 1);
        light2.position.x = -1000;
        light2.position.y = -1000;
        scene.add(light2);

        light3 = new THREE.PointLight(0x00ff00, 1);
        light3.position.x = -1000;
        light3.position.y = -1000;
        scene.add(light3);

    }

    var animate = function() {

        requestAnimationFrame(animate);

        mesh.rotation.x += parent.volume * 0.0003;
        mesh.rotation.y += parent.volume * 0.0001;

        if (parent.streamData.length > geometry.vertices.length) {
            for (var i = 0; i < parent.streamData.length; i += Math.floor(parent.streamData.length / geometry.vertices.length)) {
                //geometry.vertices[i].x = orVertices[i].x;
                if (geometry.vertices[i]) {
                    geometry.vertices[i].x = orVertices[i].x * (parent.streamData[i] / 200 + 1);
                    geometry.vertices[i].y = orVertices[i].y * (parent.streamData[i] / 200 + 1);
                    geometry.vertices[i].z = orVertices[i].z * (parent.streamData[i] / 200 + 1);
                }
            }
        } else {
            for (var i = 0; i < geometry.vertices.length; i += Math.floor(geometry.vertices.length / parent.streamData.length)) {
                //geometry.vertices[i].x = orVertices[i].x;
                if (geometry.vertices[i] && parent.streamData[i]) {
                    geometry.vertices[i].x = orVertices[i].x * (parent.streamData[i] / 100 + 1);
                    geometry.vertices[i].y = orVertices[i].y * (parent.streamData[i] / 100 + 1);
                    geometry.vertices[i].z = orVertices[i].z * (parent.streamData[i] / 100 + 1);
                }
            }
        }

        geometry.verticesNeedUpdate = true;
        light2.position.x = Math.sin(Date.now() * 0.001) * 1000;
        light2.position.y = Math.sin(Date.now() * 0.001) * 1000;
        light2.position.z = Math.sin(Date.now() * 0.001) * 1000;

        light3.position.x = Math.sin(Date.now() * 0.002 + 2.2) * 1000;
        light3.position.y = Math.sin(Date.now() * 0.002 + 2.2) * 1000;
        light3.position.z = Math.sin(Date.now() * 0.002 + 2.2) * 1000;



        var scale = (parent.volume / 255) + 1;
        mesh.scale.set(scale, scale, scale);

        renderer.render(scene, camera);


    }

    init();
    animate();
    </script>
</body>
